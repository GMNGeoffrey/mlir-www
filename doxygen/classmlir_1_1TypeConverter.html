<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::TypeConverter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">11.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1TypeConverter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::TypeConverter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for type conversion interface.  
 <a href="classmlir_1_1TypeConverter.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="DialectConversion_8h_source.html">mlir/Transforms/DialectConversion.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::TypeConverter:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1TypeConverter__inherit__graph.png" border="0" usemap="#mlir_1_1TypeConverter_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1TypeConverter_inherit__map" id="mlir_1_1TypeConverter_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1BufferAssignmentTypeConverter.html" title="A helper type converter class for using inside Buffer Assignment operation conversion patterns..." alt="" coords="191,5,375,47"/>
<area shape="rect" id="node3" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types in the Standard dialect to the LLVM IR dialect. " alt="" coords="197,71,368,98"/>
<area shape="rect" id="node4" href="classmlir_1_1SPIRVTypeConverter.html" title="Type conversion from standard types to SPIR&#45;V types for shader interface. " alt="" coords="193,122,372,149"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides all of the information necessary to convert a type signature.  <a href="classmlir_1_1TypeConverter_1_1SignatureConversion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac23c45fa40bd2771f27702f46fac5232"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ac23c45fa40bd2771f27702f46fac5232">~TypeConverter</a> ()=default</td></tr>
<tr class="separator:ac23c45fa40bd2771f27702f46fac5232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;FnT&gt;::template arg_t&lt;0&gt;&gt; </td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">addConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function.  <a href="#a272bc4144b1ac5a3f7f1ad25c0e39e03">More...</a><br /></td></tr>
<tr class="separator:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c3e12662d60542476df0feddcd9fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a98c3e12662d60542476df0feddcd9fff">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:a98c3e12662d60542476df0feddcd9fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given type.  <a href="#a98c3e12662d60542476df0feddcd9fff">More...</a><br /></td></tr>
<tr class="separator:a98c3e12662d60542476df0feddcd9fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b17254bd638b2e408c7d5f972ced99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a82b17254bd638b2e408c7d5f972ced99">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t)</td></tr>
<tr class="memdesc:a82b17254bd638b2e408c7d5f972ced99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook simplifies defining 1-1 type conversions.  <a href="#a82b17254bd638b2e408c7d5f972ced99">More...</a><br /></td></tr>
<tr class="separator:a82b17254bd638b2e408c7d5f972ced99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72eeb8558f5046e581a9c3c1dce4d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ab72eeb8558f5046e581a9c3c1dce4d77">convertTypes</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; types, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:ab72eeb8558f5046e581a9c3c1dce4d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given set of types, filling 'results' as necessary.  <a href="#ab72eeb8558f5046e581a9c3c1dce4d77">More...</a><br /></td></tr>
<tr class="separator:ab72eeb8558f5046e581a9c3c1dce4d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851e966212a7ca7d0f6ba4217cc94555"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a851e966212a7ca7d0f6ba4217cc94555">isLegal</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a851e966212a7ca7d0f6ba4217cc94555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given type is legal for this type converter, i.e.  <a href="#a851e966212a7ca7d0f6ba4217cc94555">More...</a><br /></td></tr>
<tr class="separator:a851e966212a7ca7d0f6ba4217cc94555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7475fd3c41bff5053734b346f7fb17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#acd7475fd3c41bff5053734b346f7fb17">isSignatureLegal</a> (<a class="el" href="classmlir_1_1FunctionType.html">FunctionType</a> funcType)</td></tr>
<tr class="memdesc:acd7475fd3c41bff5053734b346f7fb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the inputs and outputs of the given function type are legal.  <a href="#acd7475fd3c41bff5053734b346f7fb17">More...</a><br /></td></tr>
<tr class="separator:acd7475fd3c41bff5053734b346f7fb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d8fb83971ae60f79e79bca268547a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3a8d8fb83971ae60f79e79bca268547a">convertSignatureArg</a> (unsigned inputNo, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result)</td></tr>
<tr class="memdesc:a3a8d8fb83971ae60f79e79bca268547a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook allows for converting a specific argument of a signature.  <a href="#a3a8d8fb83971ae60f79e79bca268547a">More...</a><br /></td></tr>
<tr class="separator:a3a8d8fb83971ae60f79e79bca268547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0d70ed6d97cbb8da4ba4a6e46a475e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a9a0d70ed6d97cbb8da4ba4a6e46a475e">convertBlockSignature</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a9a0d70ed6d97cbb8da4ba4a6e46a475e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the type signature of the given block, by invoking 'convertSignatureArg' for each argument.  <a href="#a9a0d70ed6d97cbb8da4ba4a6e46a475e">More...</a><br /></td></tr>
<tr class="separator:a9a0d70ed6d97cbb8da4ba4a6e46a475e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b48a60db91e349cf724678ba41dcbbd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a4b48a60db91e349cf724678ba41dcbbd">materializeConversion</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; inputs, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a4b48a60db91e349cf724678ba41dcbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook allows for materializing a conversion from a set of types into one result type by generating a cast operation of some kind.  <a href="#a4b48a60db91e349cf724678ba41dcbbd">More...</a><br /></td></tr>
<tr class="separator:a4b48a60db91e349cf724678ba41dcbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for type conversion interface. </p>
<p>Specific converters must derive this class and implement the pure virtual functions. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00039">39</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac23c45fa40bd2771f27702f46fac5232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23c45fa40bd2771f27702f46fac5232">&#9670;&nbsp;</a></span>~TypeConverter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mlir::TypeConverter::~TypeConverter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a272bc4144b1ac5a3f7f1ad25c0e39e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272bc4144b1ac5a3f7f1ad25c0e39e03">&#9670;&nbsp;</a></span>addConversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;FnT&gt;::template arg_t&lt;0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::TypeConverter::addConversion </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a conversion function. </p>
<p>A conversion function must be convertible to any of the following forms(where <code>T</code> is a class derived from <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a></code>:</p><ul>
<li>Optional&lt;Type&gt;(T)<ul>
<li>This form represents a 1-1 type conversion. It should return nullptr or <code>llvm::None</code> to signify failure. If <code>llvm::None</code> is returned, the converter is allowed to try another conversion function to perform the conversion.</li>
</ul>
</li>
<li>Optional&lt;LogicalResult&gt;(T, SmallVectorImpl&lt;Type&gt; &amp;)<ul>
<li>This form represents a 1-N type conversion. It should return <code>failure</code> or <code>llvm::None</code> to signify a failed conversion. If the new set of types is empty, the type is removed and any usages of the existing value are expected to be removed during conversion. If <code>llvm::None</code> is returned, the converter is allowed to try another conversion function to perform the conversion. Note: When attempting to convert a type, e.g. via 'convertType', the mostly recently added conversions will be invoked first. </li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00112">112</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l01805">convertBlockSignature()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01742">convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01692">convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01717">convertTypes()</a>, <a class="el" href="DialectConversion_8h_source.html#l00053">mlir::TypeConverter::SignatureConversion::InputMapping::inputNo</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01727">isLegal()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l01735">isSignatureLegal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StandardToLLVM_8cpp_source.html#l00130">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00552">mlir::populateLinalgToLLVMConversionPatterns()</a>, and <a class="el" href="SPIRVLowering_8cpp_source.html#l00391">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>.</p>

</div>
</div>
<a id="a9a0d70ed6d97cbb8da4ba4a6e46a475e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0d70ed6d97cbb8da4ba4a6e46a475e">&#9670;&nbsp;</a></span>convertBlockSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto TypeConverter::convertBlockSignature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the type signature of the given block, by invoking 'convertSignatureArg' for each argument. </p>
<p>This function should return a valid conversion for the signature on success, None otherwise. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01805">1805</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="Block_8h_source.html#l00103">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00102">mlir::Block::getNumArguments()</a>, <a class="el" href="Value_8h_source.html#l00265">mlir::BlockArgument::getType()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00112">addConversion()</a>.</p>

</div>
</div>
<a id="a3a8d8fb83971ae60f79e79bca268547a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8d8fb83971ae60f79e79bca268547a">&#9670;&nbsp;</a></span>convertSignatureArg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> TypeConverter::convertSignatureArg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>inputNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This hook allows for converting a specific argument of a signature. </p>
<p>It takes as inputs the original argument input number, type. On success, this function should populate 'result' with any new mappings. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01742">1742</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l01656">mlir::TypeConverter::SignatureConversion::addInputs()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00933">mlir::ConversionPatternRewriter::applySignatureConversion()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01742">convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01717">convertTypes()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, <a class="el" href="Types_8cpp_source.html#l00036">mlir::FunctionType::get()</a>, <a class="el" href="OpDefinition_8h_source.html#l00128">mlir::OpState::getContext()</a>, <a class="el" href="Types_8h_source.html#l00218">mlir::FunctionType::getInput()</a>, <a class="el" href="Types_8h_source.html#l00216">mlir::FunctionType::getNumInputs()</a>, <a class="el" href="Types_8cpp_source.html#l00047">mlir::FunctionType::getResults()</a>, <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00319">mlir::PatternRewriter::updateRootInPlace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00112">addConversion()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l01742">convertSignatureArg()</a>.</p>

</div>
</div>
<a id="a98c3e12662d60542476df0feddcd9fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c3e12662d60542476df0feddcd9fff">&#9670;&nbsp;</a></span>convertType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given type. </p>
<p>This hooks allows for converting a type.</p>
<p>This function should return failure if no valid conversion exists, success otherwise. If the new set of types is empty, the type is removed and any usages of the existing value are expected to be removed during conversion. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01692">1692</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00112">addConversion()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00130">adjustAccessChainForBitwidth()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00104">mlir::barePtrFuncArgTypeConverter()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00278">mlir::LLVMTypeConverter::convertFunctionTypeCWrapper()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00088">convertMemRefTypeToBarePtr()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00084">convertRangeType()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01128">extractNDVectorTypeInfo()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00086">extractOne()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00480">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00114">getI64SubArray()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00069">getPtrToElementType()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00058">insertOne()</a>, <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html#l00302">lowerAsEntryFunction()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00028">mlir::GPUFuncOpLowering&lt; AllocaAddrSpace &gt;::matchAndRewrite()</a>, <a class="el" href="OpToFuncCallLowering_8h_source.html#l00038">mlir::OpToFuncCallLowering&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="ConvertAVX512ToLLVM_8cpp_source.html#l00041">matchAndRewriteOneToOne()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l02700">matchSimpleAtomicOp()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01191">mlir::LLVM::detail::oneToOneRewrite()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00621">mlir::MemRefDescriptor::pack()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00728">mlir::UnrankedMemRefDescriptor::pack()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00063">mlir::structFuncArgTypeConverter()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01259">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l00896">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a82b17254bd638b2e408c7d5f972ced99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b17254bd638b2e408c7d5f972ced99">&#9670;&nbsp;</a></span>convertType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This hook simplifies defining 1-1 type conversions. </p>
<p>This function returns the type to convert to on success, and a null type on failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01704">1704</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>.</p>

</div>
</div>
<a id="ab72eeb8558f5046e581a9c3c1dce4d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72eeb8558f5046e581a9c3c1dce4d77">&#9670;&nbsp;</a></span>convertTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> TypeConverter::convertTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given set of types, filling 'results' as necessary. </p>
<p>This returns failure if the conversion of any of the types fails, success otherwise. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01717">1717</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00045">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00112">addConversion()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l01742">convertSignatureArg()</a>.</p>

</div>
</div>
<a id="a851e966212a7ca7d0f6ba4217cc94555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851e966212a7ca7d0f6ba4217cc94555">&#9670;&nbsp;</a></span>isLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given type is legal for this type converter, i.e. </p>
<p>the type converts to itself. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01727">1727</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00039">mlir::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00112">addConversion()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00572">mlir::ConversionTarget::addIllegalDialect()</a>.</p>

</div>
</div>
<a id="acd7475fd3c41bff5053734b346f7fb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7475fd3c41bff5053734b346f7fb17">&#9670;&nbsp;</a></span>isSignatureLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isSignatureLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FunctionType.html">FunctionType</a>&#160;</td>
          <td class="paramname"><em>funcType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the inputs and outputs of the given function type are legal. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01735">1735</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8cpp_source.html#l00041">mlir::FunctionType::getInputs()</a>, and <a class="el" href="Types_8cpp_source.html#l00047">mlir::FunctionType::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00112">addConversion()</a>, <a class="el" href="ConvertAVX512ToLLVM_8cpp_source.html#l00152">mlir::populateAVX512ToLLVMConversionPatterns()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00552">mlir::populateLinalgToLLVMConversionPatterns()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01106">mlir::populateVectorToLLVMMatrixConversionPatterns()</a>.</p>

</div>
</div>
<a id="a4b48a60db91e349cf724678ba41dcbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b48a60db91e349cf724678ba41dcbbd">&#9670;&nbsp;</a></span>materializeConversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::TypeConverter::materializeConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This hook allows for materializing a conversion from a set of types into one result type by generating a cast operation of some kind. </p>
<p>The generated operation should produce one result, of 'resultType', with the provided 'inputs' as operands. This hook must be overridden when a type conversion results in more than one type, or if a type conversion may persist after the conversion has finished. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1LLVMTypeConverter.html#aab4500b06bccedbddc0d85d2d93f23fd">mlir::LLVMTypeConverter</a>.</p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00157">157</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00274">mlir::Type::dyn_cast()</a>, <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>, <a class="el" href="LogicalResult_8h_source.html#l00025">mlir::success()</a>, and <a class="el" href="Attributes_8h_source.html#l00142">mlir::StandardAttributes::Type</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Transforms/<a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a></li>
<li>lib/Transforms/<a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 6 2020 00:28:57 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
